#ifndef _WIND_NUMBERS_H_
#define _WIND_NUMBERS_H_

#include <list>
#include <math.h>

class Numbers
{
private:
	typedef std::pair<int, int> NumPair;

public:
	static std::list<int> * GetPrimesTo (int n)
	{
		std::list<int> * primes = new std::list<int> ();
		// A loop over all of the numbers up to the desired number.
		// Each loop will check to see if it is a prime, by checking
		// to see if it is divisible by a list of primes up to
		// that has been accumulated thus far, but we will only 
		// check up to prime <= sqrt(n). If the number is prime, it will
		// be added to the list of primes.

		// Add 2,3 to primes if n is large enough.
		// Get these cases out of the way so that we do not have
		// to test for them for every iteration of the following 
		//major loop.
		if (n > 1) primes->push_back(2);
		if (n > 2) primes->push_back(3);

		// For the rest of the numbers (odd numbers)...
		for (int i = 5; i <= n; i += 2)
		{
			// See if they are divisible by numbers in our list of
			// primes, only up to sqrt(n) - don't check past sqrt(n)
			// because doing so is a repetition of effort.
			double sqrt_i = sqrt(i);
			bool is_prime = true;
			//std::cout << "get_primes_to: check " << i << " for factors up to " << (sqrt_i + 1) << std::endl;
			for (std::list<int>::iterator p = primes->begin(); p != primes->end() && *p < (sqrt_i + 1); ++p)
			{
				//std::cout << "get_primes_to: " << i << " % " << *p << std::endl;
				if (i % *p == 0)
				{
					is_prime = false;
					break;
				}
			}

			// If it is prime, let us add it to the list of primes.
			// Let us also add it to the list of consecutive (odd)
			// primes if it was consecutive.
			if (is_prime)
			{
				// Now, add it..
				primes->push_back(i);
			}
		}

		// Add it at the end. All numbers are divisible by 1,
		// this will mess up the previous calculations.
		primes->push_front(1);
		return primes;
	}

	static int * GetPermutations (int size)
	{
		return 0;
	}
};
#endif
